Grammar <- Spacing contents? EOF

variable_name <-
    IDENT (COLON2 IDENT)*

// optional modifier: a-z (overkill...)
regexp_primary <-
	"%r{" sp ('\\' . / !'}' .)+ '}' [a-z]* sp

hash_primary <- LCURLY (hash_key_value (COMMA hash_key_value)*)? RCURLY

hash_key <- STRING / IDENT

hash_key_value <- hash_key COLON expression

html_primary <-
	"%html{" sp 
		(	&IDENT html_code* 
		/	&'<'   html_tag*
		)
		RCURLY

html_code <-
	IDENT  (LPAREN param_expression_list? RPAREN)? LCURLY
		html_code_content*
	RCURLY

html_code_content <-
	inline_eval
/	html_code
/	!RCURLY .

html_tag <-
	'<' IDENT html_attribute* '>'
		html_tag_content*
	("</" IDENT GT)?

html_tag_content <-
	inline_eval
/	html_tag
/	!RCURLY .

html_attribute <-
	IDENT EQ STRING

sass_primary <-
	"%sass{" sp 
		sass_content*
	RCURLY

sass_content <-
	LCURLY (!RCURLY sass_content)* RCURLY
/	inline_eval
/	STRING
/	!RCURLY .

inline_eval <- "#{" sp expression RCURLY

array_primary <-
    LBRACK (expression_list)? RBRACK
    //array of (w) words or (s) symbols
//TODO: make more exact w/ IDENTS, etc...
/   '%' [ws] '{' sp ('\\' . / !'}')* RCURLY

primary_expression <-
    K_NIL QMARK?
/   K_NEW
/   K_FILE / K_TARGET
/   K_TRUE / K_FALSE
/   K_THIS / K_SUPER
/   STRING
/   SYMBOL
/	LPAREN expression RPAREN
/   here_doc
/   variable_name (QMARK / EXCL)?
/   Number
/   hash_primary
/   array_primary
/   regexp_primary
/	html_primary
/	sass_primary

postfix_expression <-
    postfix_expression LBRACK array_select_expression RBRACK block?
/   postfix_expression LPAREN param_expression_list? RPAREN block?
/   postfix_expression dot_suffix block?
/   postfix_expression (PLUS2 / MINUS2) 
/   primary_expression block?

unary_expression <-
	unary_op unary_expression
/   postfix_expression

// STAR/STAR2 are splat operators (as in ruby)
unary_op <- TILDE / EXCL / PLUS / MINUS / STAR / STAR2 / PLUS2 / MINUS2 / AND

mult_expression <-
	mult_expression mult_op unary_expression
/	unary_expression
	
mult_op <- STAR / DIV / PCNT

add_expression <-
	add_expression add_op mult_expression
/	mult_expression

add_op <- PLUS / MINUS

shift_expression <-
	shift_expression shift_op add_expression
/	add_expression

shift_op <- LT2 / GT2

rel_expression <-
	rel_expression rel_op shift_expression
/	shift_expression

rel_op <- LT / LTEQ / GT / GTEQ

cmp_expression <-
	cmp_expression cmp_op rel_expression
/	rel_expression

cmp_op <- NEQ / EQ2 / REXEQ / REXNEQ

and_expression <-
	and_expression AND cmp_expression
/	cmp_expression

xor_expression <-
	xor_expression CARET and_expression
/	and_expression

or_expression <-
	or_expression OR xor_expression
/	xor_expression

land_expression <-
	land_expression AND2 or_expression
/	or_expression

lor_expression <-
	lor_expression OR2 land_expression
/	land_expression

conditional_expression <-
    lor_expression QMARK expression COLON expression
/	lor_expression

expression <- conditional_expression

binary_op <-
	mult_op
/	add_op
/	shift_op
/	rel_op
/	cmp_op
/	AND / OR / CARET / AND2 / OR2

dot_suffix <-
    DOT (   K_NIL QMARK?
        	/   K_NEW
        	/   METHOD_NAME_IDENT (EXCL / QMARK)?
        	)

block <- anonymous_function

expression_list <- expression (COMMA expression)*

unnamed_param <- expression_list

named_param_ele <- IDENT COLON expression

// last: can be vararg
named_param <- named_param_ele (COMMA named_param_ele)* (COMMA expression)*

// Any named params are at the end
param_expression_list <- 
	unnamed_param named_param
/	named_param
/	unnamed_param

array_select_expression <-
    expression DOT2 expression
/   expression_list

var_decl <- lhs_decl IDENT (COMMA IDENT)* eos

assignment_lhs <- lhs_decl lhs_ref (COMMA lhs_ref)*

lhs_decl <- access_modifier? K_STATIC? mutability?

lhs_ref <-
    lhs_ref LBRACK array_select_expression RBRACK
/   lhs_ref LPAREN param_expression_list? RPAREN
/   lhs_ref DOT METHOD_NAME_IDENT (EXCL / QMARK)?
/   lhs_ref (PLUS2 / MINUS2) 
/   variable_name

assignment_op <-
    EQ
/   LT2_EQ
/   GT2_EQ
/   AND_EQ
/   OR_EQ
/   STAR_EQ
/   MINUS_EQ
/   PLUS_EQ
/   DIV_EQ
/   PCNT_EQ
    
contents <-
    require_statement* file_item+

require_statement <- K_REQUIRE STRING eos

file_item <-
    module_declaration
/   statement

module_item <-
    var_decl_statement
/   assign_statement
/   class_declaration 
/   method_declaration
/   module_declaration

statement <- 
    case_statement
/   if_statement
/   while_statement
/   until_statement
/   for_statement
/   block_statement
/   break_statement
/   next_statement
/   alias_statement
/   return_statement 
/   try_statement 
/   throw_statement
/   class_declaration
/   method_declaration 
/   mixin_statement
/   assign_statement
/   var_decl_statement
/   expression_statement

block_statement <- LCURLY statement* RCURLY  ;
break_statement <- K_BREAK eos ;
next_statement <-  K_NEXT eos ;
alias_statement <- K_ALIAS method_name method_name eos ;
assign_statement <- assignment_lhs assignment_op assignment_rhs eos ;
var_decl_statement <- var_decl eos ;
expression_statement <- expression eos ;

try_statement <-
    K_TRY statement
        catch_statement*
        finally_statement?
		eos

// NOTE: while ruby allows most statements as rhs; e.g.: "foo = if xxx; 12", 
// we will not.  Use method to do so.
assignment_rhs <-
    expression_list
/   anonymous_function

return_statement <- K_RETURN (expression)? eos

throw_statement <- K_THROW expression eos

catch_statement <- K_CATCH expression statement eos

finally_statement <- K_FINALLY statement eos

mixin_name <-
    IDENT (COLON2 IDENT)*

mixin_statement <- K_MIXIN module_name (COMMA module_name)* eos
    
s_tail <-
    statement_modifier eos
/   eos

module_name <- IDENT

module_declaration <-
    K_MODULE module_name LCURLY
        module_item*
    RCURLY eos

class_name <- IDENT

class_declaration <-
    // Scala style
    access_modifier?
    K_ABSTRACT?
    K_CLASS class_name
        method_param_decl?
        class_extends?
        LCURLY 
            class_body
        RCURLY eos

//1st statement is initializer
class_body <- base_class_initializer? statement*

base_class_initializer <- K_SUPER method_param_decl 

method_param_decl <- LPAREN method_param_decl_list? RPAREN

access_modifier <- (K_PRIVATE / K_PROTECTED / K_PUBLIC) 

mutability <- (K_CONST / K_VAR) 

method_param_decl_modifier <- access_modifier? mutability?

method_param_decl_ele <-
    //NOTE: only last in list can have STAR (marks as varargs)
    // AND (&) marks as function parameter
    method_param_decl_modifier (AND / STAR)? IDENT (method_param_decl_default)?

method_param_decl_default <- EQ expression

method_param_decl_list <- method_param_decl_ele (COMMA method_param_decl_ele)*  

class_extends <- 
	K_EXTENDS class_name (K_IMPLEMENTS class_name_list)?
/	K_IMPLEMENTS class_name_list

class_name_list <- class_name (COMMA class_name)*

anonymous_function <- ARROW method_param_decl LCURLY method_body RCURLY

method_declaration <-
    access_modifier?
    (K_ABSTRACT | K_STATIC)?
    K_DEF method_name (method_param_decl)?
        (LCURLY method_body RCURLY)?
        //NOTE: abstract declaration if empty
		eos
    
method_name <-
    METHOD_NAME_IDENT? method_name_op
/   METHOD_NAME_IDENT

method_name_op <-
    LBRACK RBRACK EQ  // []=
/   LBRACK RBRACK     // []
/   LPAREN RPAREN     // ()
/   unary_op
/   binary_op
/   QMARK
/   EXCL
/   assignment_op
/   PLUS2 / MINUS2  //postix operator
/   ("++_" / "--_") sp //prefix operator

method_body <- statement*
    
case_statement <-
    K_CASE expression LCURLY 
        (K_WHEN expression_list COLON statement)*
        (K_ELSE statement)?
    RCURLY eos

if_statement <-
    (K_IF / K_UNLESS) expression statement
        (K_ELSIF expression statement)*
        (K_ELSE statement)?

while_statement <- K_WHILE expression statement eos
until_statement <- K_UNTIL expression statement eos

enumerable_expression <- expression

for_statement <- K_FOR IDENT K_IN enumerable_expression statement eos
;

// a bit more complicated, so customize
here_doc.

//
//Lexical syntax
COLON       <- ':' !':' Spacing
COLON2      <- "::" Spacing
SEMI        <- ';' Spacing
DOT         <- '.' !'.' Spacing
DOT2        <- ".." Spacing
COMMA       <- ',' Spacing
LT          <- '<' !('<' / '=') Spacing
LTEQ        <- "<=" Spacing
LT2         <- "<<" !('=' / [a-zA-Z_]) Spacing
LT2_EQ      <- "<<=" Spacing
GT          <- '>' !('>' / '=') Spacing
GTEQ        <- ">=" Spacing
GT2         <- ">>" !'=' Spacing
GT2_EQ      <- ">>=" Spacing
EQ          <- '=' !('=' / '~') Spacing
EQ2         <- "==" Spacing
REXEQ       <- "=~" Spacing
EXCL        <- '!' !('=' / '~') Spacing
NEQ         <- "!=" Spacing
REXNEQ      <- "!~" Spacing
//AT          <- '@' !'@' Spacing
//AT2         <- "@@" Spacing
TILDE       <- '~' Spacing
CARET       <- '^' Spacing
AND         <- '&' !('&' / '=') Spacing
AND2        <- "&&" Spacing
AND_EQ      <- "&=" Spacing
OR          <- '|' !('|' / '=') Spacing
OR2         <- "||" Spacing
OR_EQ       <- "|=" Spacing
STAR        <- '*' !('=' / '*') Spacing
STAR2       <- "**" Spacing
STAR_EQ     <- "*=" Spacing
MINUS       <- '-' !('-' / '=' / '>') Spacing
MINUS2      <- "--" Spacing
MINUS_EQ    <- "-=" Spacing
ARROW       <- "->" Spacing
PLUS        <- '+' !('+' / '=') Spacing
PLUS2       <- "++" Spacing
PLUS_EQ     <- "+=" Spacing
QMARK       <- '?' Spacing
DIV         <- '/' !'=' Spacing
DIV_EQ      <- "/=" Spacing
LCURLY      <- '{' Spacing
RCURLY      <- '}' Spacing
LPAREN      <- '(' Spacing
RPAREN      <- ')' Spacing
LBRACK      <- '[' Spacing
RBRACK      <- ']' Spacing
PCNT        <- '%' !'=' Spacing
PCNT_EQ     <- "%=" Spacing

K_ABSTRACT  <- "abstract"   K_tail
K_ALIAS     <- "alias"      K_tail
K_BREAK     <- "break"      K_tail
K_CASE      <- "case"       K_tail
K_CATCH     <- "catch"      K_tail
K_CLASS     <- "class"      K_tail
K_CONST     <- "const"      K_tail
K_DEF       <- "def"        K_tail
K_ELSE      <- "else"       K_tail
K_ELSIF     <- "elsif"      K_tail
K_EXTENDS   <- "extends"    K_tail
K_FALSE     <- "false"      K_tail
K_FINALLY   <- "finally"    K_tail
K_FOR       <- "for"        K_tail
K_IF        <- "if"         K_tail
K_IMPLEMENTS <- "implements" K_tail
K_IN        <-  "in"        K_tail
K_MIXIN     <-  "mixin"     K_tail
K_MODULE    <- "module"     K_tail
K_NEXT      <- "next"       K_tail
K_NEW       <- "new"        K_tail
K_NIL       <- "nil"        K_tail
K_PRIVATE   <- "private"    K_tail
K_PROTECTED <- "protected"  K_tail
K_PUBLIC    <- "public"     K_tail
K_REQUIRE   <- "require"    K_tail
K_RETURN    <- "return"     K_tail
K_STATIC    <- "static"     K_tail
K_SUPER     <- "super"      K_tail
K_THIS      <- "this"       K_tail
K_THROW     <- "throw"      K_tail
K_TRUE      <- "true"       K_tail
K_TRY       <- "try"        K_tail
K_UNLESS    <- "unless"     K_tail
K_UNTIL     <- "until"      K_tail
K_VAR       <- "var"        K_tail
K_WHEN      <- "when"       K_tail
K_WHILE     <- "while"      K_tail
K_FILE      <- "__FILE__"   K_tail
//Specifies target language
K_TARGET    <- "__TARGET__" K_tail

K_tail <- !IdentCont Spacing
IdentCont <- [a-zA-Z_0-9]

SYMBOL  <- COLON IDENT Spacing
;

IDENT.

// Allow class methods to include keywords too
METHOD_NAME_IDENT <-
    [a-zA-Z] IdentCont* Spacing

Number <-   (   BasedNumber
            /   Integer
            /   Float
            ) Spacing

//{DO NOT USE THESE DIRECTLY: use Number above
Integer <- Digits !('.' | [eE])
Digits <- [0-9] [0-9_]* !'\''
Float <- Digits ('.' Digits)? ([eE] ('-'|'+')? Digits)?
BasedNumber <- ([0-9] [0-9_]*)? !STRING '\''
                ( [bB] [01_]+
                / [dD] [0-9_]+
                / [hH] [a-fA-F0-9_]+
                / [oO] [0-7_]+
                )
//}

//NOTE: Double quoted string contains 0 or more chars.
//      Single quoted string contains 0 or 1 char.
//todo: If change single quoted to accept more, we get an infinite parser loop
STRING <- 
    '"'  ('\\' . / !'"'  .)* '"'  Spacing
/   '\'' ('\\' . / !'\'' .)? '\'' Spacing

//Spacing <- (WS / Comment / EOL)*
Spacing <- SpacingWithSemi

Comment <- SL_COMMENT / ML_COMMENT;
WS. // ' '/'\t'

SL_COMMENT  <- "//" (!EOL .)* EOL

ML_COMMENT <- "/*" (!"*/" .)* "*/"
;

eos <- SemiOrEOL 
/      (WS / Comment)* &'}'
/	   WS* statement_modifier
/	   &EOF
;

statement_modifier <- (K_IF / K_UNLESS / K_WHILE / K_UNTIL) expression eos
;

//ATRUE.  	//always true (but does not consume)
SemiOrEOL.	//true if SpacingWithSemi ended w/ semi or nl
SpacingWithSemi. // <- (SEMI / WS / Comment / EOL)*
sp <- (SEMI / WS / Comment / EOL)*
