/*
 * The MIT License
 *
 * Copyright 2016 gburdell.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Grammar <- Spacing contents? EOF

regexp_primary <-
	"%r{" sp regexp_item2+ '}' [i]? sp
/	'/' regexp_item1+ '/' [i]? sp

regexp_item1 <-
	inline_eval
/	"#{"
/	('\\' . / !"#{" !'/' .)+

regexp_item2 <-
	inline_eval
/	"#{"
/	('\\' . / !"#{" !'}' .)+

hash_primary <- LCURLY (hash_key_value (COMMA hash_key_value)*)? RCURLY

hash_key <- STRING / IDENT

hash_key_value <- hash_key COLON expression

html_primary <-
	"%html{" sp 
		(	&IDENT html_code* 
		/	&'<'   html_tag*
		)
		RCURLY

html_code <-
	IDENT  (LPAREN param_expression_list? RPAREN)? LCURLY
		html_code_content*
	RCURLY

html_code_content <-
	inline_eval
/	html_code
/	!RCURLY .

html_tag <-
	'<' IDENT html_attribute* '>'
		html_tag_content*
	("</" IDENT GT)?

html_tag_content <-
	inline_eval
/	html_tag
/	!RCURLY .

html_attribute <-
	IDENT EQ STRING

sass_primary <-
	"%sass{" sp 
		sass_content*
	RCURLY

sass_content <-
	LCURLY (!RCURLY sass_content)* RCURLY
/	inline_eval
/	STRING
/	!RCURLY .

inline_eval <- "#{" sp expression RCURLY

array_primary <-
    LBRACK (expression_list)? RBRACK
    //array of (w) words or (s) symbols
/   '%' [ws] LCURLY IDENT* RCURLY

primary_expression <-
    K_NIL
/   K_FILE / K_TARGET
/   K_TRUE / K_FALSE
/   K_THIS / K_SUPER
/   STRING
/   SYMBOL
/	LPAREN expression RPAREN
/   here_doc
/   scoped_name
/   Number
/   hash_primary
/   array_primary
/   regexp_primary
/	html_primary
/	sass_primary

scoped_name <- 
	COLON2? IDENTNK (COLON2 IDENTNK)*

postfix_expression <-
    postfix_expression LBRACK array_select_expression RBRACK block?
/   postfix_expression LPAREN param_expression_list? RPAREN block?
/   postfix_expression dot_suffix block?
/   postfix_expression (PLUS2 / MINUS2) 
/   primary_expression block?

unary_expression <-
	unary_op unary_expression
/   postfix_expression

unary_op <- TILDE / EXCL / PLUS / MINUS / STAR / STAR2 / PLUS2 / MINUS2 / AND

mult_expression <-
	mult_expression mult_op unary_expression
/	unary_expression
	
mult_op <- STAR / DIV / PCNT

add_expression <-
	add_expression add_op mult_expression
/	mult_expression

add_op <- PLUS / MINUS

shift_expression <-
	shift_expression shift_op add_expression
/	add_expression

shift_op <- LT2 / GT2

rel_expression <-
	rel_expression rel_op shift_expression
/	shift_expression

rel_op <- LT / LTEQ / GT / GTEQ

cmp_expression <-
	cmp_expression cmp_op rel_expression
/	rel_expression

cmp_op <- CMP / NEQ / EQ2 / REXEQ / REXNEQ

and_expression <-
	and_expression AND cmp_expression
/	cmp_expression

xor_expression <-
	xor_expression CARET and_expression
/	and_expression

or_expression <-
	or_expression OR xor_expression
/	xor_expression

land_expression <-
	land_expression AND2 or_expression
/	or_expression

lor_expression <-
	lor_expression OR2 land_expression
/	land_expression

conditional_expression <-
    lor_expression QMARK expression COLON expression
/	lor_expression

expression <- conditional_expression

binary_op <-
	mult_op
/	add_op
/	shift_op
/	rel_op
/	cmp_op
/	AND / OR / CARET / AND2 / OR2

dot_suffix <- DOT (K_NIL / K_NEW / IDENTNK)

block <- anonymous_function_defn

expression_list <- expression (COMMA expression)*

unnamed_param <- expression_list

named_param_ele <- param_name COLON expression

// last: can be vararg
named_param <- named_param_ele (COMMA named_param_ele)* (COMMA expression)*

// Any named params are at the end
param_expression_list <- 
	unnamed_param named_param
/	named_param
/	unnamed_param

array_select_expression <-
    expression DOT2 expression
/   expression_list

var_decl_statement <- 
	(	type_decl scoped_name 
	/	scoped_name
	)
	(COMMA scoped_name)* 
	(assignment_op assignment_rhs)? eos

assign_statement <- assignment_lhs assignment_op assignment_rhs eos

assignment_lhs <- type_decl? lhs_ref (COMMA lhs_ref)*

type_decl <- access_modifier? K_STATIC? mutability? type_name

lhs_ref <-
    lhs_ref LBRACK array_select_expression RBRACK
/   lhs_ref LPAREN param_expression_list? RPAREN
/   lhs_ref DOT IDENTNK
/   lhs_ref (PLUS2 / MINUS2) 
/   scoped_name

assignment_op <-
    EQ
/   LT2_EQ
/   GT2_EQ
/   AND_EQ
/   OR_EQ
/   STAR_EQ
/   MINUS_EQ
/   PLUS_EQ
/   DIV_EQ
/   PCNT_EQ
    
contents <-
    require_statement* file_item+

require_statement <- K_REQUIRE STRING eos

file_item <-
    module_declaration
/   statement

module_item <-
    var_decl_statement
/   assign_statement
/   class_declaration 
/   interface_declaration 
/   method_declaration
/   module_declaration

statement <- 
    case_statement
/   if_statement
/   while_statement
/   until_statement
/   for_statement
/   block_statement
/   break_statement
/   next_statement
/   alias_statement
/   return_statement 
/   try_statement 
/   throw_statement
/   class_declaration
/   interface_declaration 
/   method_declaration 
/   mixin_statement
/   assign_statement
/   var_decl_statement
/   expression_statement

block_statement <- LCURLY statement* RCURLY  ;
break_statement <- K_BREAK eos ;
next_statement <-  K_NEXT eos ;
alias_statement <- K_ALIAS method_name method_name eos ;
expression_statement <- expression eos ;

try_statement <-
    K_TRY statement
        catch_statement*
        finally_statement?
		eos

// NOTE: while ruby allows most statements as rhs; e.g.: "foo = if xxx; 12", 
// we will not.  Use method to do so.
assignment_rhs <-
    expression_list
/   anonymous_function_defn

return_statement <- K_RETURN (expression)? eos

throw_statement <- K_THROW expression eos

catch_statement <- K_CATCH expression eos statement eos

finally_statement <- K_FINALLY statement eos

mixin_name <- scoped_name

mixin_statement <- K_MIXIN module_name (COMMA module_name)* eos
    
module_name <- scoped_name

module_declaration <-
    K_MODULE module_name LCURLY
        module_item*
    RCURLY eos

class_name <- scoped_name

class_declaration <-
    access_modifier?
    K_CLASS class_name
        method_param_decl?
        class_extends?
        LCURLY 
            class_body
        RCURLY eos

interface_declaration <-
    access_modifier?
    K_INTERFACE class_name
		(K_IMPLEMENTS class_name_list)?
        LCURLY 
            class_body
        RCURLY eos

//1st statement is initializer
class_body <- base_class_initializer? statement*

base_class_initializer <- K_SUPER method_param_decl 

access_modifier <- (K_PRIVATE / K_PROTECTED / K_PUBLIC) 

mutability <- (K_CONST / K_VAR) 

method_param_decl <- LPAREN method_param_decl_list? RPAREN

method_param_decl_modifier <- access_modifier? mutability?

method_param_decl_list <- method_param_decl_ele (COMMA method_param_decl_ele)*  

method_param_decl_ele <-
    //NOTE: only last in list can have STAR (marks as varargs)
    // AND (&) marks as function parameter
    method_param_decl_modifier 
	(	anonymous_function_decl	
	/	type_name STAR? param_name method_param_decl_default?
	/	STAR? param_name method_param_decl_default?
	)

// @foo declares foo as a member
param_name <- AT? IDENTNK

type_name <- 
	builtin_type_name 
/ 	scoped_name

builtin_type_name <-
	K_INT / K_DOUBLE / K_BOOL / K_STRING
/	LCURLY RCURLY
/	LBRACK RBRACK
/	QMARK

method_param_decl_default <- EQ expression

class_extends <- 
	K_EXTENDS class_name (K_IMPLEMENTS class_name_list)?
/	K_IMPLEMENTS class_name_list

class_name_list <- class_name (COMMA class_name)*

anonymous_function_decl <- 
	ARROW param_name method_param_decl? method_return_decl?

method_return_decl <-
	EQGT type_name
/	EQGT LPAREN method_return_ele (COMMA method_return_ele)* RPAREN

method_return_ele <- type_name param_name?

anonymous_function_defn <-
	ARROW method_param_decl method_return_decl? LCURLY method_body? RCURLY 

method_declaration <-
    access_modifier?
    K_STATIC?
    K_DEF method_name method_param_decl? method_return_decl?
        //NOTE: abstract declaration if empty
        (LCURLY method_body RCURLY)?
		eos
    
method_name <-
    method_name_op
/   scoped_name

method_name_op <-
    LBRACK RBRACK EQ  // []=
/   LBRACK RBRACK     // []
/   LPAREN RPAREN     // ()
/   unary_op
/   binary_op
// /   QMARK
// /   EXCL
/   assignment_op
/   PLUS2 / MINUS2  //postix operator
/   ("++_" / "--_") sp //prefix operator

method_body <- statement*
    
case_statement <-
    K_CASE expression LCURLY 
        (K_WHEN expression_list COLON statement)*
        (K_ELSE statement)?
    RCURLY eos

if_statement <-
    (K_IF / K_UNLESS) expression eos statement eos
        (K_ELSIF expression eos statement eos)*
        (K_ELSE statement eos)?

while_statement <- K_WHILE expression eos statement eos
until_statement <- K_UNTIL expression eos statement eos

enumerable_expression <- expression

for_statement <- K_FOR IDENTNK K_IN enumerable_expression eos statement eos
;

// a bit more complicated, so customize
here_doc.

//
//Lexical syntax
COLON       <- ':' !':' Spacing
COLON2      <- "::" Spacing
SEMI        <- ';' Spacing
DOT         <- '.' !'.' Spacing
DOT2        <- ".." Spacing
COMMA       <- ',' Spacing
LT          <- '<' !('<' / '=') Spacing
CMP         <- "<=>" Spacing
LTEQ        <- "<=" !'>' Spacing
LT2         <- "<<" !('=' / [a-zA-Z_]) Spacing
LT2_EQ      <- "<<=" Spacing
GT          <- '>' !('>' / '=') Spacing
GTEQ        <- ">=" Spacing
GT2         <- ">>" !'=' Spacing
GT2_EQ      <- ">>=" Spacing
EQ          <- '=' !('=' / '~' / '>') Spacing
EQGT        <- "=>" Spacing
EQ2         <- "==" Spacing
REXEQ       <- "=~" Spacing
EXCL        <- '!' !('=' / '~') Spacing
NEQ         <- "!=" Spacing
REXNEQ      <- "!~" Spacing
AT          <- '@' !'@' Spacing
//AT2         <- "@@" Spacing
TILDE       <- '~' Spacing
CARET       <- '^' Spacing
AND         <- '&' !('&' / '=') Spacing
AND2        <- "&&" Spacing
AND_EQ      <- "&=" Spacing
OR          <- '|' !('|' / '=') Spacing
OR2         <- "||" Spacing
OR_EQ       <- "|=" Spacing
STAR        <- '*' !('=' / '*') Spacing
STAR2       <- "**" Spacing
STAR_EQ     <- "*=" Spacing
MINUS       <- '-' !('-' / '=' / '>') Spacing
MINUS2      <- "--" Spacing
MINUS_EQ    <- "-=" Spacing
ARROW       <- "->" Spacing
PLUS        <- '+' !('+' / '=') Spacing
PLUS2       <- "++" Spacing
PLUS_EQ     <- "+=" Spacing
QMARK       <- '?' Spacing
DIV         <- '/' !'=' Spacing
DIV_EQ      <- "/=" Spacing
LCURLY      <- '{' Spacing
RCURLY      <- '}' Spacing
LPAREN      <- '(' Spacing
RPAREN      <- ')' Spacing
LBRACK      <- '[' Spacing
RBRACK      <- ']' Spacing
PCNT        <- '%' !'=' Spacing
PCNT_EQ     <- "%=" Spacing

K_ALIAS     <- "alias"      K_tail
K_BREAK     <- "break"      K_tail
K_BOOL      <- "bool"       K_tail
K_CASE      <- "case"       K_tail
K_CATCH     <- "catch"      K_tail
K_CLASS     <- "class"      K_tail
K_CONST     <- "const"      K_tail
K_DEF       <- "def"        K_tail
K_DOUBLE    <- "double"     K_tail
K_ELSE      <- "else"       K_tail
K_ELSIF     <- "elsif"      K_tail
K_EXTENDS   <- "extends"    K_tail
K_FALSE     <- "false"      K_tail
K_FINALLY   <- "finally"    K_tail
K_FOR       <- "for"        K_tail
K_IF        <- "if"         K_tail
K_IMPLEMENTS <- "implements" K_tail
K_INT		<-  "int"       K_tail
K_IN        <-  "in"        K_tail
K_INTERFACE <-  "interface" K_tail
K_MIXIN     <-  "mixin"     K_tail
K_MODULE    <- "module"     K_tail
K_NEXT      <- "next"       K_tail
K_NEW       <- "new"        K_tail
K_NIL       <- "nil" '?'?   K_tail
K_PRIVATE   <- "private"    K_tail
K_PROTECTED <- "protected"  K_tail
K_PUBLIC    <- "public"     K_tail
K_REQUIRE   <- "require"    K_tail
K_RETURN    <- "return"     K_tail
K_STATIC    <- "static"     K_tail
K_STRING    <- "string"     K_tail
K_SUPER     <- "super"      K_tail
K_THIS      <- "this"       K_tail
K_THROW     <- "throw"      K_tail
K_TRUE      <- "true"       K_tail
K_TRY       <- "try"        K_tail
K_UNLESS    <- "unless"     K_tail
K_UNTIL     <- "until"      K_tail
K_VAR       <- "var"        K_tail
K_WHEN      <- "when"       K_tail
K_WHILE     <- "while"      K_tail
K_FILE      <- "__FILE__"   K_tail
//Specifies target language
K_TARGET    <- "__TARGET__" K_tail

K_tail <- ![_a-zA-Z0-9] Spacing

SYMBOL  <- ':' IDENTNK Spacing
;

// includes optional '?'
IDENT.

//same as IDENT by No Keywords allowed
IDENTNK.

Number <-   (   BasedNumber
            /   Integer
            /   Float
            ) Spacing

//{DO NOT USE THESE DIRECTLY: use Number above
Integer <- Digits !('.' | [eE])
Digits <- [0-9] [0-9_]* !'\''
Float <- Digits ('.' Digits)? ([eE] ('-'|'+')? Digits)?
BasedNumber <- ([0-9] [0-9_]*)? !STRING '\''
                ( [bB] [01_]+
                / [dD] [0-9_]+
                / [hH] [a-fA-F0-9_]+
                / [oO] [0-7_]+
                )
//}

//NOTE: Double quoted string contains 0 or more chars.
//      Single quoted string contains 0 or 1 char.
//todo: If change single quoted to accept more, we get an infinite parser loop
STRING <- 
    '"'  string_item* '"'  Spacing
/   '\'' ('\\' . / !'\'' .)? '\'' Spacing

string_item <-
	inline_eval
/	"#{"
/	('\\' . / !"#{" !'"' .)+

//Spacing <- (WS / Comment / EOL)*
Spacing <- SpacingWithSemi

Comment <- SL_COMMENT / ML_COMMENT;
WS. // ' '/'\t'

SL_COMMENT  <- "//" (!EOL .)* EOL

ML_COMMENT <- "/*" (!"*/" .)* "*/"
;

eos <- SemiOrEOL 
/      (WS / Comment)* &'}'
/	   WS* statement_modifier
/	   &EOF
;

statement_modifier <- (K_IF / K_UNLESS / K_WHILE / K_UNTIL) expression eos
;

//ATRUE.  	//always true (but does not consume)
SemiOrEOL.	//true if SpacingWithSemi ended w/ semi or nl
SpacingWithSemi. // <- (SEMI / WS / Comment / EOL)*
sp <- (SEMI / WS / Comment / EOL)*
